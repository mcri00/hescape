#!/usr/bin/env python3
import os, sys, fnmatch, shutil, hashlib
from pathlib import Path
import argparse, yaml, requests
from tqdm import tqdm
from huggingface_hub import snapshot_download, hf_hub_url, list_repo_files

def ensure_dir(p: Path):
    p.mkdir(parents=True, exist_ok=True)
    return p

def sha256_of(path: Path) -> str:
    h = hashlib.sha256()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()

def download_direct(url: str, out_path: Path, timeout=60):
    # Supporto Google Drive file grandi via gdown
    if "drive.google.com" in url or "uc?export=download" in url:
        try:
            import gdown
            out_tmp = str(out_path) + ".part"
            gdown.download(url, out_tmp, quiet=False)
            Path(out_tmp).replace(out_path)
            return
        except Exception as e:
            print(f"   ! gdown failed for Google Drive: {e}; fallback to requests…")
    # Fallback generico con requests
    out_tmp = out_path.with_suffix(out_path.suffix + ".part")
    with requests.get(url, stream=True, timeout=timeout) as r:
        r.raise_for_status()
        total = int(r.headers.get("content-length", 0))
        pbar = tqdm(total=total, unit="B", unit_scale=True, desc=f"GET {out_path.name}")
        with out_tmp.open("wb") as f:
            for chunk in r.iter_content(chunk_size=1024*256):
                if chunk:
                    f.write(chunk)
                    pbar.update(len(chunk))
        pbar.close()
    out_tmp.replace(out_path)


def copy_selected(src_dir: Path, dst_dir: Path, patterns):
    ensure_dir(dst_dir)
    copied = []
    for root, _, files in os.walk(src_dir):
        for name in files:
            rel = Path(root).joinpath(name).relative_to(src_dir)
            if any(fnmatch.fnmatch(name, pat) for pat in patterns):
                dst = dst_dir / name
                if dst.exists():
                    # skip if same hash
                    if sha256_of(dst) == sha256_of(Path(root)/name):
                        continue
                shutil.copy2(Path(root)/name, dst)
                copied.append(dst)
    return copied

def pull_hf(repo_id: str, cache_dir: Path) -> Path:
    local_dir = snapshot_download(repo_id=repo_id, cache_dir=str(cache_dir), local_files_only=False)
    return Path(local_dir)

def process_block(root_dir: Path, family: str, name: str, spec: dict, cache_dir: Path):
    target_dir = ensure_dir(root_dir / family / name)
    hf_repo = spec.get("hf_repo")
    include = spec.get("include") or []
    direct_urls = spec.get("direct_urls") or []

    print(f"\n==> {family}/{name}")
    if hf_repo:
        try:
            print(f"   - pulling HF repo: {hf_repo}")
            local = pull_hf(hf_repo, cache_dir)
            copied = copy_selected(local, target_dir, include if include else ["*"])
            if copied:
                print(f"   - copied {len(copied)} files to {target_dir}")
            else:
                print(f"   - no files matched patterns {include}, check 'include' or repo contents")
        except Exception as e:
            print(f"   ! HF pull failed for {hf_repo}: {e}")

    for url in direct_urls:
        try:
            fname = url.split("/")[-1].split("?")[0]
            outp = target_dir / fname
            if outp.exists():
                print(f"   - exists, skip: {outp.name}")
                continue
            print(f"   - downloading: {url}")
            download_direct(url, outp)
        except Exception as e:
            print(f"   ! direct download failed: {url} -> {e}")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default="tools/weights_map.yaml")
    ap.add_argument("--cache", default="~/.cache/hf_weights")
    args = ap.parse_args()

    cfg = yaml.safe_load(Path(args.config).read_text())
    root_dir = ensure_dir(Path(cfg.get("root_dir","pretrain_weights")))
    cache_dir = ensure_dir(Path(os.path.expanduser(args.cache)))

    for family in ["image","gene"]:
        block = (cfg.get(family) or {})
        for name, spec in block.items():
            process_block(root_dir, family, name, spec, cache_dir)

    print("\nAll done ✅")

if __name__ == "__main__":
    main()
